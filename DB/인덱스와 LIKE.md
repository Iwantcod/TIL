# 인덱스와 LIKE

- [와일드카드와 인덱스](#와일드카드와-인덱스)
  - ['%단어%'의 인덱스 활용](#단어의-인덱스-활용)
  - [인덱스 스캔의 조건](#인덱스-스캔의-조건)

## 와일드카드와 인덱스
기본적으로 LIKE를 이용한 조건문에 와일드카드(%)를 사용하게 되면, 와일드카드를 단어의 우측에만 붙이는 경우를 제외하면 인덱스를 활용할 수 없다고 알고 있다.

```sql
// 인덱스 활용 불가
select * from users where email like '%test';
```

단어의 우측에 와일드카드를 적용하는 경우 인덱스를 활용할 수 있는 이유는 `B-Tree 내부 구성 방식`에 있다.<br>
인덱스는 **왼쪽부터 순서가 정렬**되어 정해져있다. 그리고 문자열의 경우 B-Tree는 **왼쪽 접두어**를 기준으로 탐색 범위를 결정한다. 따라서 와일드카드가 단어의 오른쪽에만 위치하는 경우 탐색 시작 위치를 정할 수 있어 인덱스 활용이 가능한 것이다.

```sql
// 이 경우도 가능. 단, 'te%' 까지만 인덱스 적용
select * from users where email like 'te%t';
```

### '%단어%'의 인덱스 활용
'%단어%'에서도 인덱스가 활용될 수 있다. 인덱스 '탐색'은 불가능하지만, `인덱스 '스캔'`은 가능하다.<br>
첫번째 예시로 소개된 쿼리문의 경우 '테이블 풀 스캔'이 아니라, '인덱스 리프노드 풀 스캔'이 수행된다. 이 둘의 차이는 I/O 대상의 차이다.<br>
테이블 풀 스캔은 말 그대로 '모든 데이터 조회'이지만, 인덱스 리프노드 풀 스캔은 '인덱스 키'와 'PK'값만이 포함된 리프노드를 모두 조회하는 것이다. 따라서 상대적으로 훨씬 더 가볍다.

### 인덱스 스캔의 조건
> `커버링 인덱스`가 가능해야 한다.<br>
> 그렇지 않다면 PK를 이용한 클러스터링 인덱스로의 접근이 추가적으로 발생하고, 오히려 테이블 풀 스캔보다 느려질 수 있다.

예를 들어
```sql
select * from users where roles = 'seller' and email like '%email%';
```
위 쿼리문에서 인덱스 스캔만으로 조회 대상 레코드를 찾아내려면 (roles, email) 조합의 복합인덱스를 통해 커버링 인덱스가 가능해야 한다.
