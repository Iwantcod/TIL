# JPA N+1 문제


### N+1 문제란?
JPA에서 연관된 엔티티에 대한 반복적인 접근으로 인해 N개의 추가적인 쿼리문이 실행되는 현상을 말한다.

## 실습
상황: Post와 Comment 양방향 연관관계 설정, JPA가 'Post_Comment' 테이블 자동 생성<br>
데이터: 3개의 Post, 1개의 Post 당 3개의 Comment

<img width="335" height="269" alt="Image" src="https://github.com/user-attachments/assets/b6d65a1d-47b9-447b-81da-dc460a067d01" />

### 문제 발생
Case 1
1. N개의 Post 조회
2. 각 Post의 List< Comment > 필드에 접근 <- N+1 발생

Case 2
1. N개의 Comment 조회
2. 각 Comment의 Post 필드의 메서드 호출(ex: comment.getPost().getTitle())

연관관계 Loading 전략에 따라 두 케이스의 1번과 2번 과정에서 모두 N+1 문제가 발생할 수 있다.
- Eager Loading: 대상 엔티티가 조회된 시점(1번 과정)에 연관관계에 해당하는 필드가 비어있다면 추가적인 쿼리문을 실행하여 초기화한다.
- Lazy Loading: 연관관계에 해당하는 필드가 비어있다면 프록시 객체로 채운다. 이후 프록시 객체의 필드에 대한 접근(getter)이 발생하면, 그때 추가적인 쿼리문을 실행하여 초기화한다.

## Loading 전략에 따른 문제 발생 위치 차이
단방향 연관관계가 일반적으로 더 자주 활용되므로, Case 2를 기준으로 알아보자.

실행 코드
```java
List<Comment> comments = em.createQuery("from Comment", Comment.class).getResultList(); // Eager Loading: JPA N+1 발생 지점
for (Comment comment : comments) {
//comment.getPost().getId(); // 외래키 호출의 경우 추가적인 쿼리문 실행 X
  System.out.println(comment.getPost().getContent()); // Lazy Loading: JPA N+1 발생 지점
}
```

### Eager Loading

Entity가 애플리케이션에 반환되기 전에 모든 필드가 초기화되어야 한다.

```bash
Hibernate: select c1_0.id,c1_0.content,c1_0.post_id from Comment c1_0
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,p2_0.id,p2_0.content,p2_0.title from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id left join Post p2_0 on p2_0.id=c1_1.post_id where p1_0.id=?
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,p2_0.id,p2_0.content,p2_0.title from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id left join Post p2_0 on p2_0.id=c1_1.post_id where p1_0.id=?
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,p2_0.id,p2_0.content,p2_0.title from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id left join Post p2_0 on p2_0.id=c1_1.post_id where p1_0.id=?
post content1
post content1
post content1
post content2
post content2
post content2
post content3
post content3
post content3
```

1. Comment 리스트를 조회한다.
2. 조회한 시점에 각 Comment 마다 Post 타입 필드에 데이터가 존재하는지 검사한다.
3. 존재하지 않는다면 해당 데이터를 얻기 위한 조회 쿼리문을 즉시 실행한다.
4. 이후 로직이 수행된다.

### Lazy Loading

Entity가 애플리케이션에 반환될 때 초기화되지 않은 연관관계 필드는 프록시 객체로 채운다.

```bash
Hibernate: select c1_0.id,c1_0.content,c1_0.post_id from Comment c1_0
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,c1_1.post_id from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id where p1_0.id=?
post content1
post content1
post content1
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,c1_1.post_id from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id where p1_0.id=?
post content2
post content2
post content2
Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content,c1_1.post_id from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id where p1_0.id=?
post content3
post content3
post content3
```

1. Comment 리스트를 조회한다.
2. 로직을 수행한다.
3. 각 Comment의 Post 필드에 대한 필드 접근(.getPost().getContent())이 발생한다.
4. Post 필드에 대한 데이터가 없으므로 조회 쿼리문을 실행하여 데이터를 얻는다.


## JPA Loading 방식 의문점

왜 JPA에서는 Join 연산을 통해 연관관계에 속한 Entity 객체를 바로 조회하지 않는 것일까? 단순하게 생각해볼 수 있는 이유로는 다음과 같다.
> 해당 Entity를 조회한 시점에서는 연관된 Entity에 대한 접근 여부가 확실하지 않으므로 join을 수행하지 않는다.

따라서 연관된 Entity에 접근하지 않는 경우에는 불필요한 join 연산을 하지 않음으로써 자원을 절약한다.

### 즉시 로딩은 왜 존재할까?
즉시 로딩은 연관된 Entity에 대한 정보를 '즉시' 조회하는 방식이다. 그러나 이 경우 N+1 문제가 발생할 가능성이 있어 위험하다. 정말 연관된 Entity 정보가 필요하다면 Join 연산을 통해 한 번의 쿼리로 데이터를 조회하면 된다.<br>
그렇다면 도대체 왜 즉시 로딩이 존재하는지에 대해 생각해보았다. 내가 생각한 답은 성능을 떠나 쿼리문을 몰라도 개발할 수 있도록 돕기 위한 기능이라는 것이다. 즉시 로딩과 같은 기능이 있다면 Join에 대한 존재를 몰라도 된다.

### 즉시 로딩을 사용하지 않는 이유
N+1을 발생시킬 수 있는 위험도 있지만, 추가적인 쿼리문을 즉시 실행한다는 점 때문에 개발자가 예상하지 못한 쿼리문이 실행될 수가 있기 때문이다.<br>
그리고 무엇보다 Fetch Join 등을 통해 연관 Entity를 한번에 조회할 수 있기 때문에, 사용해야 할 이유가 딱히 없기 때문이다.